<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #e94560;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: linear-gradient(45deg, #0f0f1a, #1a1a2e);
            background-size: cover;
            background-position: center;
        }

        .ui-container {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(233, 69, 96, 0.7);
        }

        .game-over, .start-screen, .pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            text-align: center;
            z-index: 10;
            transition: opacity 0.5s ease, transform 0.5s ease;
            backdrop-filter: blur(5px);
            border-radius: 8px;
        }

        .hidden {
            display: none;
        }
        
        .game-logo {
            margin-bottom: 15px;
            animation: pulse 2s infinite ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .menu-btn {
            background: linear-gradient(45deg, #16213e, #0f3460);
            color: #e94560;
            border: 2px solid #e94560;
            transition: all 0.3s ease;
        }
        
        .menu-btn:hover {
            background: #e94560;
            color: white;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #e94560;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.7);
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #e94560;
        }

        p {
            margin: 10px 0;
            font-size: 1.2rem;
        }

        button {
            background: linear-gradient(45deg, #e94560, #c73e6b);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.8);
        }
        
        .pulse-btn {
            animation: pulse-btn 1.5s infinite;
        }
        
        @keyframes pulse-btn {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .highlight-score {
            font-size: 1.5em;
            color: #e94560;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.7);
        }
        
        .tagline {
            color: #e94560;
            font-style: italic;
            margin-bottom: 20px;
        }
        
        .instructions {
            margin: 15px 0;
            padding: 15px;
            background: rgba(15, 15, 30, 0.6);
            border-radius: 10px;
            border-left: 4px solid #e94560;
        }
        
        .controls-reminder {
            margin-top: 20px;
            padding: 15px;
            background: rgba(15, 15, 30, 0.6);
            border-radius: 10px;
            max-width: 80%;
        }
        
        .controls-reminder h3 {
            color: #e94560;
            margin-bottom: 10px;
        }
        
        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }
        
        .game-over-title {
            animation: fade-in 1s ease;
        }
        
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .score-display {
            animation: pop-in 0.5s ease 0.3s both;
        }
        
        @keyframes pop-in {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .controls {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #ccc;
        }

        .high-scores {
            margin-top: 20px;
            width: 80%;
            max-width: 300px;
        }

        .high-scores h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .high-scores ol {
            text-align: left;
            padding-left: 20px;
        }

        .high-scores li {
            margin: 5px 0;
        }

        .power-up-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            background: rgba(10, 10, 20, 0.7);
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
            display: flex;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .power-up-indicator.active {
            opacity: 1;
        }

        .power-up-icon {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 50%;
        }

        .sound-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(10, 10, 20, 0.7);
            border: none;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 5;
        }

        @media (max-width: 600px) {
            .game-container {
                width: 95vw;
                height: auto;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .ui-container {
                font-size: 16px;
            }
            
            .instructions p,
            .controls-reminder p {
                font-size: 0.9rem;
            }
            
            .tagline {
                font-size: 1rem;
            }
            
            .game-logo svg {
                width: 60px;
                height: 60px;
            }
            
            .menu-options {
                gap: 5px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
            
            .high-scores {
                max-width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="score">Score: 0</div>
        <div id="high-score">High Score: 0</div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="power-up-indicator" id="powerUpIndicator">
            <div class="power-up-icon" id="powerUpIcon"></div>
            <span id="powerUpText"></span>
        </div>
        
        <button class="sound-toggle" id="soundToggle">🔊</button>

        <div class="start-screen" id="startScreen">
            <h1>Enhanced Snake Game</h1>
            <p>Use Arrow Keys or WASD to move</p>
            <p>Collect food to grow and earn points</p>
            <p>Watch out for special power-ups!</p>
            <p>Avoid walls and obstacles that appear in different levels</p>
            <p>Every 50 points advances you to a new level!</p>
            <button id="startButton">Start Game</button>
            <div class="controls">
                <p>P: Pause Game | M: Toggle Sound</p>
            </div>

        </div>
        
        <div class="game-over hidden" id="gameOverScreen">
            <h2 class="game-over-title">Game Over</h2>
            <div class="score-display">
                <p>Your Score: <span id="finalScore" class="highlight-score">0</span></p>
            </div>
            <div class="menu-options">
                <button id="restartButton" class="pulse-btn">Play Again</button>
                <button id="gameOverMainMenuButton" class="menu-btn">Main Menu</button>
            </div>
            
            <div class="high-scores">
                <h3>High Scores</h3>
                <ol id="highScoresList"></ol>
            </div>
        </div>
        
        <div class="pause-screen hidden" id="pauseScreen">
            <h2>Game Paused</h2>
            <div class="menu-options">
                <button id="resumeButton" class="pulse-btn">Resume Game</button>
                <button id="mainMenuButton" class="menu-btn">Main Menu</button>
            </div>
            <div class="controls-reminder">
                <h3>Controls</h3>
                <p>Arrow Keys/WASD: Move Snake</p>
                <p>P: Pause/Resume</p>
                <p>M: Toggle Sound</p>
            </div>
        </div>
    </div>

    <script>
        // Game Configuration
        const config = {
            canvasWidth: 600,
            canvasHeight: 400,
            gridSize: 20,
            initialSpeed: 150,
            speedIncrease: 0.5,
            maxSpeed: 50,
            responsive: true,
            soundEnabled: true,
            gravity: 0.5,               // Gravity strength
            groundLevel: 380,           // Y position of the ground (slightly above canvas height)
            platformHeight: 10          // Height of platforms
        };


        // Game State
        const gameState = {
            snake: [],
            direction: 'right',
            nextDirection: 'right',
            food: { x: 0, y: 0, type: 'regular' },
            score: 0,
            highScore: 0,
            gameOver: false,
            paused: false,
            lastRenderTime: 0,
            gameSpeed: config.initialSpeed,
            powerUp: null,
            particles: [],
            foodTypes: [
                { type: 'regular', color: '#e94560', points: 1, probability: 0.7, size: 1 },
                { type: 'bonus', color: '#ffbd69', points: 3, probability: 0.2, size: 1.2 },
                { type: 'special', color: '#00f5d4', points: 5, probability: 0.1, size: 1.5 }
            ],
            powerUps: [
                { type: 'speed', color: '#ff2e63', duration: 5000, icon: '⚡' },
                { type: 'immunity', color: '#00b8a9', duration: 8000, icon: '🛡️' },
                { type: 'multiplier', color: '#8a2be2', duration: 10000, icon: '✖️' }
            ],
            activePowerUp: null,
            powerUpTimer: null,
            konami: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65], // Up Up Down Down Left Right Left Right B A
            konamiIndex: 0,
            easterEggActivated: false,
            // Add level-related properties
            currentLevel: 0,
            levels: [],
            platforms: []
        };

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const finalScoreElement = document.getElementById('finalScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const pauseScreen = document.getElementById('pauseScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const resumeButton = document.getElementById('resumeButton');
        const highScoresList = document.getElementById('highScoresList');
        const powerUpIndicator = document.getElementById('powerUpIndicator');
        const powerUpIcon = document.getElementById('powerUpIcon');
        const powerUpText = document.getElementById('powerUpText');
        const soundToggle = document.getElementById('soundToggle');
        
        // Image preloading
        const platformImages = {};

        // Initialize canvas size
        function setupCanvas() {
            if (config.responsive) {
                const containerWidth = Math.min(window.innerWidth * 0.95, config.canvasWidth);
                const containerHeight = Math.min(window.innerHeight * 0.7, config.canvasHeight);
                
                canvas.width = Math.floor(containerWidth / config.gridSize) * config.gridSize;
                canvas.height = Math.floor(containerHeight / config.gridSize) * config.gridSize;
            } else {
                canvas.width = config.canvasWidth;
                canvas.height = config.canvasHeight;
            }
        }

        // Initialize game
        function initGame() {
            setupCanvas();
            
            // Load level configuration
            loadLevelConfig()
                .then(() => {
                    // Select initial level
                    setLevel(0);
                    
                    // Create initial snake
                    gameState.snake = [
                        { x: Math.floor(canvas.width / config.gridSize / 2) * config.gridSize, 
                          y: Math.floor(canvas.height / config.gridSize / 2) * config.gridSize }
                    ];
                    
                    gameState.direction = 'right';
                    gameState.nextDirection = 'right';
                    gameState.score = 0;
                    gameState.gameOver = false;
                    gameState.gameSpeed = config.initialSpeed;
                    gameState.particles = [];
                    gameState.activePowerUp = null;
                    gameState.easterEggActivated = false;
                    
                    if (gameState.powerUpTimer) {
                        clearTimeout(gameState.powerUpTimer);
                        gameState.powerUpTimer = null;
                    }
                    
                    // Load high score from localStorage
                    const savedHighScore = localStorage.getItem('snakeHighScore');
                    if (savedHighScore) {
                        gameState.highScore = parseInt(savedHighScore);
                        highScoreElement.textContent = `High Score: ${gameState.highScore}`;
                    }
                    
                    // Generate initial food
                    generateFood();
                    
                    // Update score display
                    updateScore();
                    
                    // Start game loop
                    window.requestAnimationFrame(gameLoop);
                });
        }
        
        // Load level configuration from JSON
        async function loadLevelConfig() {
            try {
                const response = await fetch('assets/level_config.json');
                if (!response.ok) {
                    throw new Error(`Failed to load level config: ${response.status}`);
                }
                const config = await response.json();
                gameState.levels = config.levels;
                gameState.platformTypes = config.platformTypes;
                
                // Preload platform images
                for (const type in config.platformTypes) {
                    preloadImage(type, config.platformTypes[type].imagePath);
                }
                
                return true;
            } catch (error) {
                console.error('Failed to load level configuration:', error);
                // Fallback to default level if config can't be loaded
                gameState.levels = [{
                    name: "Default Level",
                    background: "",
                    description: "Default level when configuration cannot be loaded",
                    platforms: []
                }];
                gameState.platformTypes = {};
                return true; // Return true anyway so game can start
            }
        }
        
        // Preload image
        function preloadImage(type, path) {
            const img = new Image();
            img.src = path;
            platformImages[type] = img;
        }
        
        // Set current level
        function setLevel(levelIndex) {
            if (levelIndex >= gameState.levels.length) {
                levelIndex = 0; // Loop back to first level
            }
            
            gameState.currentLevel = levelIndex;
            const level = gameState.levels[levelIndex];
            
            // Set background
            canvas.style.backgroundImage = `url('${level.background}')`;
            
            // Load platforms
            gameState.platforms = level.platforms.map(platform => {
                // Convert platform definition to actual game objects
                const result = [];
                for (let x = 0; x < platform.width; x++) {
                    for (let y = 0; y < platform.height; y++) {
                        result.push({
                            x: platform.x + (x * config.gridSize),
                            y: platform.y + (y * config.gridSize),
                            type: platform.type
                        });
                    }
                }
                return result;
            }).flat();
        }
        
        // Advance to next level
        function advanceLevel() {
            // Create level change effect
            createLevelTransitionEffect();
            
            // Set timeout to change level
            setTimeout(() => {
                // Move to next level
                setLevel((gameState.currentLevel + 1) % gameState.levels.length);
                
                // Generate new food in case the previous one is now inside a platform
                generateFood();
            }, 1000);
        }
        
        // Create level transition effect
        function createLevelTransitionEffect() {
            // Flash effect - add overlay with fade out
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(233, 69, 96, 0.3)';
            overlay.style.zIndex = '5';
            overlay.style.pointerEvents = 'none';
            overlay.style.transition = 'opacity 1s ease-out';
            
            // Add level text
            const levelText = document.createElement('div');
            levelText.textContent = `LEVEL ${(gameState.currentLevel + 2)}`;
            levelText.style.position = 'absolute';
            levelText.style.top = '50%';
            levelText.style.left = '50%';
            levelText.style.transform = 'translate(-50%, -50%)';
            levelText.style.color = '#fff';
            levelText.style.fontSize = '2rem';
            levelText.style.fontWeight = 'bold';
            levelText.style.textShadow = '0 0 10px rgba(233, 69, 96, 0.8)';
            overlay.appendChild(levelText);
            
            document.querySelector('.game-container').appendChild(overlay);
            
            // Fade out after a short delay
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                }, 1000);
            }, 100);

        }

        // Generate food at random position
        function generateFood() {
            // Determine food type based on probability
            let foodType;
            const rand = Math.random();
            let cumulativeProbability = 0;
            
            for (const type of gameState.foodTypes) {
                cumulativeProbability += type.probability;
                if (rand <= cumulativeProbability) {
                    foodType = type.type;
                    break;
                }
            }
            
            // Generate random position that doesn't overlap with snake or platforms
            let position;
            let validPosition = false;
            
            while (!validPosition) {
                position = {
                    x: Math.floor(Math.random() * (canvas.width / config.gridSize)) * config.gridSize,
                    y: Math.floor(Math.random() * (canvas.height / config.gridSize)) * config.gridSize
                };
                
                // Check if position is not on a platform and not occupied by snake
                validPosition = !isPositionOccupied(position) && !isPositionOnPlatform(position);
            }
            
            gameState.food = { ...position, type: foodType };
            
            // Occasionally spawn a power-up (10% chance when no active power-up)
            if (!gameState.activePowerUp && Math.random() < 0.1) {
                generatePowerUp();
            }
        }

        // Generate power-up at random position
        function generatePowerUp() {
            // Select random power-up type
            const powerUpType = gameState.powerUps[Math.floor(Math.random() * gameState.powerUps.length)];
            
            // Generate random position that doesn't overlap with snake or food
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * (canvas.width / config.gridSize)) * config.gridSize,
                    y: Math.floor(Math.random() * (canvas.height / config.gridSize)) * config.gridSize
                };
            } while (isPositionOccupied(position) || 
                    (position.x === gameState.food.x && position.y === gameState.food.y));
            
            gameState.powerUp = { ...position, ...powerUpType };
        }
        
        // Generate enemy at random position
        function generateEnemy() {
            // Don't spawn if we're at max enemies
            if (gameState.enemies.length >= gameState.maxEnemies) {
                return;
            }
            
            // Select random enemy type
            const enemyType = gameState.enemyTypes[Math.floor(Math.random() * gameState.enemyTypes.length)];
            
            // Generate random position that doesn't overlap with snake, food, or power-up
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * (canvas.width / config.gridSize)) * config.gridSize,
                    y: Math.floor(Math.random() * (canvas.height / config.gridSize)) * config.gridSize
                };
            } while (
                isPositionOccupied(position) || 
                (position.x === gameState.food.x && position.y === gameState.food.y) ||
                (gameState.powerUp && position.x === gameState.powerUp.x && position.y === gameState.powerUp.y) ||
                // Don't spawn too close to snake head
                Math.abs(position.x - gameState.snake[0].x) < config.gridSize * 3 &&
                Math.abs(position.y - gameState.snake[0].y) < config.gridSize * 3
            );
            
            // For patrol pattern, determine a patrol path
            let patrolPath = null;
            if (enemyType.movementPattern === 'patrol') {
                // Create a simple patrol line
                const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                const patrolLength = Math.floor(Math.random() * 5) + 3; // 3-7 squares
                patrolPath = {
                    direction: direction,
                    length: patrolLength * config.gridSize,
                    current: 0,
                    increasing: true
                };
            }
            
            // Add enemy to game state
            gameState.enemies.push({
                ...position,
                ...enemyType,
                targetDirection: Math.random() < 0.5 ? 'right' : 'left', // Initial random direction
                animationOffset: Math.random() * 1000, // For slightly different animation timing
                patrolPath: patrolPath
            });

          // Check if position is on a platform
        function isPositionOnPlatform(position) {
            for (const platform of gameState.platforms) {
                if (position.y + config.gridSize > platform.y && 
                    position.y < platform.y + platform.height &&
                    position.x + config.gridSize > platform.x && 
                    position.x < platform.x + platform.width) {
                    return true;
                }
            }
            return false;
        }

        // Generate power-up at random position
        function generatePowerUp() {
            // Select random power-up type
            const powerUpType = gameState.powerUps[Math.floor(Math.random() * gameState.powerUps.length)];
            
            // Generate random position that doesn't overlap with snake, food, or platforms
            let position;
            let validPosition = false;
            
            while (!validPosition) {
                position = {
                    x: Math.floor(Math.random() * (canvas.width / config.gridSize)) * config.gridSize,
                    y: Math.floor(Math.random() * (canvas.height / config.gridSize)) * config.gridSize
                };
                
                // Check if position is not occupied by snake, not the same as food, and not on a platform
                validPosition = !isPositionOccupied(position) && 
                               !(position.x === gameState.food.x && position.y === gameState.food.y) &&
                               !isPositionOnPlatform(position);
            }
            
            gameState.powerUp = { ...position, ...powerUpType };
        }

        // Generate platforms in the game
        function generatePlatforms() {
            // Clear existing platforms
            gameState.platforms = [];
            
            // Add the ground (bottom platform that spans the entire width)
            gameState.platforms.push({
                x: 0,
                y: config.groundLevel,
                width: canvas.width,
                height: config.platformHeight,
                color: '#555555'
            });
            
            // Add some floating platforms at various heights
            // Platform 1: Left side
            gameState.platforms.push({
                x: 0,
                y: 300,
                width: 200,
                height: config.platformHeight,
                color: '#555555'
            });
            
            // Platform 2: Middle
            gameState.platforms.push({
                x: 250,
                y: 200,
                width: 150,
                height: config.platformHeight,
                color: '#555555'
            });
            
            // Platform 3: Right side
            gameState.platforms.push({
                x: 450,
                y: 320,
                width: 150,
                height: config.platformHeight,
                color: '#555555'
            });
            
            // Platform 4: Upper left
            gameState.platforms.push({
                x: 100,
                y: 100,
                width: 100,
                height: config.platformHeight,
                color: '#555555'
            });
        }

        // Check if position is occupied by snake or platform
        function isPositionOccupied(position) {
            // Check if position is occupied by snake
            if (gameState.snake.some(segment => 
                segment.x === position.x && segment.y === position.y
            )) {
                return true;
            }
            
            // Check if position is occupied by platform
            if (gameState.platforms.some(platform => 
                platform.x === position.x && platform.y === position.y
            )) {
                return true;
            }
            
            return false;
        }

        // Update game state
        function update() {
            if (gameState.gameOver || gameState.paused) return;
            
            // Get current head position
            const head = { ...gameState.snake[0] };
            
            // Update direction
            gameState.direction = gameState.nextDirection;
            
            // Calculate new head position based on direction
            switch (gameState.direction) {
                case 'up':
                    head.y -= config.gridSize;
                    break;
                case 'down':
                    head.y += config.gridSize;
                    break;
                case 'left':
                    head.x -= config.gridSize;
                    break;
                case 'right':
                    head.x += config.gridSize;
                    break;
            }
            
            // Check for wall collision
            if (head.x < 0 || head.x >= canvas.width || 
                head.y < 0 || head.y >= canvas.height) {
                if (gameState.activePowerUp && gameState.activePowerUp.type === 'immunity') {
                    // Wrap around with immunity
                    if (head.x < 0) head.x = canvas.width - config.gridSize;
                    if (head.x >= canvas.width) head.x = 0;
                    if (head.y < 0) head.y = canvas.height - config.gridSize;
                    if (head.y >= canvas.height) head.y = 0;
                } else {
                    handleGameOver();
                    return;
                }
            }
            
            // Check for self collision
            if (gameState.snake.some((segment, index) => 
                index > 0 && segment.x === head.x && segment.y === head.y)) {
                if (!(gameState.activePowerUp && gameState.activePowerUp.type === 'immunity')) {
                    handleGameOver();
                    return;
                }
            }
            
            // Check for platform collision
            if (gameState.platforms.some(platform => 
                platform.x === head.x && platform.y === head.y)) {
                if (!(gameState.activePowerUp && gameState.activePowerUp.type === 'immunity')) {
                    handleGameOver();
                    return;
                }
            }
            
            // Add new head to snake
            gameState.snake.unshift(head);
            
            // Check for food collision
            if (head.x === gameState.food.x && head.y === gameState.food.y) {
                // Find food type details
                const foodTypeDetails = gameState.foodTypes.find(type => type.type === gameState.food.type);
                
                // Calculate points
                let points = foodTypeDetails.points;
                
                // Apply multiplier if active
                if (gameState.activePowerUp && gameState.activePowerUp.type === 'multiplier') {
                    points *= 2;
                }
                
                // Update score
                gameState.score += points;
                updateScore();
                
                // Create particles
                createParticles(gameState.food.x + config.gridSize/2, gameState.food.y + config.gridSize/2, 
                                foodTypeDetails.color, 10);
                
                // Generate new food
                generateFood();
                
                // Increase speed slightly
                if (gameState.gameSpeed > config.maxSpeed) {
                    gameState.gameSpeed -= config.speedIncrease;
                }
                
                // Check if should advance level (every 50 points)
                if (gameState.score % 50 === 0 && gameState.levels.length > 1) {
                    advanceLevel();
                }
            } 
            // Check for power-up collision
            else if (gameState.powerUp && head.x === gameState.powerUp.x && head.y === gameState.powerUp.y) {
                activatePowerUp(gameState.powerUp);
                gameState.powerUp = null;
            }
            else {
                // Remove tail if no food was eaten
                gameState.snake.pop();
            }
            
            // Update enemies
            updateEnemies();
            
            // Randomly spawn enemies if we're below max
            if (gameState.enemies.length < gameState.maxEnemies && Math.random() < gameState.enemySpawnRate) {
                generateEnemy();
            }
            
            // Check for enemy collisions with snake head
            checkEnemyCollisions();
            
            // Update particles
            updateParticles();
        }
        
        // Update enemy positions based on their movement patterns
        function updateEnemies() {
            gameState.enemies.forEach(enemy => {
                // Calculate movement increment based on enemy speed
                const moveIncrement = enemy.speed * config.gridSize / 20;
                
                // Apply different movement patterns
                switch (enemy.movementPattern) {
                    case 'random':
                        // Randomly change direction sometimes
                        if (Math.random() < 0.02) {
                            const directions = ['up', 'down', 'left', 'right'];
                            enemy.targetDirection = directions[Math.floor(Math.random() * directions.length)];
                        }
                        
                        // Move in current direction
                        moveEnemy(enemy, enemy.targetDirection, moveIncrement);
                        
                        // Bounce off walls
                        if (enemy.x < 0) {
                            enemy.x = 0;
                            enemy.targetDirection = 'right';
                        }
                        if (enemy.x > canvas.width - config.gridSize) {
                            enemy.x = canvas.width - config.gridSize;
                            enemy.targetDirection = 'left';
                        }
                        if (enemy.y < 0) {
                            enemy.y = 0;
                            enemy.targetDirection = 'down';
                        }
                        if (enemy.y > canvas.height - config.gridSize) {
                            enemy.y = canvas.height - config.gridSize;
                            enemy.targetDirection = 'up';
                        }
                        break;
                        
                    case 'follow':
                        // Calculate direction towards snake head
                        const head = gameState.snake[0];
                        
                        // Only update direction occasionally to make movement less perfect
                        if (Math.random() < 0.05) {
                            if (Math.abs(enemy.x - head.x) > Math.abs(enemy.y - head.y)) {
                                // Move horizontally
                                enemy.targetDirection = enemy.x < head.x ? 'right' : 'left';
                            } else {
                                // Move vertically
                                enemy.targetDirection = enemy.y < head.y ? 'down' : 'up';
                            }
                        }
                        
                        // Move towards player
                        moveEnemy(enemy, enemy.targetDirection, moveIncrement);
                        break;
                        
                    case 'patrol':
                        if (enemy.patrolPath.direction === 'horizontal') {
                            // Move horizontally
                            const direction = enemy.patrolPath.increasing ? 'right' : 'left';
                            moveEnemy(enemy, direction, moveIncrement);
                            
                            // Update patrol path position
                            enemy.patrolPath.current += enemy.patrolPath.increasing ? moveIncrement : -moveIncrement;
                            
                            // Reverse direction at path ends
                            if (enemy.patrolPath.current >= enemy.patrolPath.length) {
                                enemy.patrolPath.increasing = false;
                            } else if (enemy.patrolPath.current <= 0) {
                                enemy.patrolPath.increasing = true;
                            }
                        } else {
                            // Move vertically
                            const direction = enemy.patrolPath.increasing ? 'down' : 'up';
                            moveEnemy(enemy, direction, moveIncrement);
                            
                            // Update patrol path position
                            enemy.patrolPath.current += enemy.patrolPath.increasing ? moveIncrement : -moveIncrement;
                            
                            // Reverse direction at path ends
                            if (enemy.patrolPath.current >= enemy.patrolPath.length) {
                                enemy.patrolPath.increasing = false;
                            } else if (enemy.patrolPath.current <= 0) {
                                enemy.patrolPath.increasing = true;
                            }
                        }
                        break;
                }
            });
        }
        
        // Move enemy in specified direction
        function moveEnemy(enemy, direction, amount) {
            switch (direction) {
                case 'up':
                    enemy.y -= amount;
                    break;
                case 'down':
                    enemy.y += amount;
                    break;
                case 'left':
                    enemy.x -= amount;
                    break;
                case 'right':
                    enemy.x += amount;
                    break;
            }
        }
        
        // Check for collisions between snake and enemies
        function checkEnemyCollisions() {
            const head = gameState.snake[0];
            
            // Calculate approximate collision (with some leeway for smoother gameplay)
            const collisionDistance = config.gridSize * 0.7;
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Check if snake head collides with enemy
                const dx = (head.x + config.gridSize/2) - (enemy.x + config.gridSize/2);
                const dy = (head.y + config.gridSize/2) - (enemy.y + config.gridSize/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < collisionDistance) {
                    // If player has immunity, destroy the enemy
                    if (gameState.activePowerUp && gameState.activePowerUp.type === 'immunity') {
                        // Create particles for explosion effect
                        createParticles(enemy.x + config.gridSize/2, enemy.y + config.gridSize/2, 
                                      enemy.color, 20);
                        
                        // Remove the enemy
                        gameState.enemies.splice(i, 1);
                        
                        // Give player some points
                        gameState.score += 10;
                        updateScore();
                    } else {
                        // Game over on collision
                        handleGameOver();
                        return;
                    }
                }
            }

          // Check if a segment is on a platform
        function isOnPlatform(segment) {
            // Check if segment is on any platform
            for (const platform of gameState.platforms) {
                // Check if segment's bottom edge is at the platform's top edge
                if (segment.y + config.gridSize >= platform.y && 
                    segment.y + config.gridSize <= platform.y + 5 && // Small tolerance for collision
                    segment.x + config.gridSize > platform.x && 
                    segment.x < platform.x + platform.width) {
                    return true;
                }
            }
            return false;
        }

        // Update game state
        function update() {
            if (gameState.gameOver || gameState.paused) return;
            
            // Get current head position
            const head = { ...gameState.snake[0] };
            
            // Update direction
            gameState.direction = gameState.nextDirection;
            
            // Calculate new head position based on direction
            switch (gameState.direction) {
                case 'up':
                    if (gameState.isGrounded) {
                        // Jump if on platform
                        gameState.verticalVelocity = -8;
                        gameState.isGrounded = false;
                    }
                    head.y -= config.gridSize;
                    break;
                case 'down':
                    head.y += config.gridSize;
                    break;
                case 'left':
                    head.x -= config.gridSize;
                    break;
                case 'right':
                    head.x += config.gridSize;
                    break;
            }
            
            // Apply gravity to the head if not grounded
            if (!gameState.isGrounded) {
                gameState.verticalVelocity += config.gravity;
                head.y += gameState.verticalVelocity;
            }
            
            // Check if head is on a platform
            gameState.isGrounded = isOnPlatform(head);
            
            // If grounded, reset vertical velocity
            if (gameState.isGrounded) {
                gameState.verticalVelocity = 0;
                
                // Adjust head position to sit on top of the platform
                for (const platform of gameState.platforms) {
                    if (head.y + config.gridSize >= platform.y && 
                        head.y + config.gridSize <= platform.y + 5 &&
                        head.x + config.gridSize > platform.x && 
                        head.x < platform.x + platform.width) {
                        head.y = platform.y - config.gridSize;
                        break;
                    }
                }
            }
            
            // Check for wall collision
            if (head.x < 0 || head.x >= canvas.width || 
                head.y < 0 || head.y >= canvas.height) {
                if (gameState.activePowerUp && gameState.activePowerUp.type === 'immunity') {
                    // Wrap around with immunity
                    if (head.x < 0) head.x = canvas.width - config.gridSize;
                    if (head.x >= canvas.width) head.x = 0;
                    if (head.y < 0) head.y = canvas.height - config.gridSize;
                    if (head.y >= canvas.height) head.y = 0;
                } else {
                    handleGameOver();
                    return;
                }
            }
            
            // Check for self collision
            if (gameState.snake.some((segment, index) => 
                index > 0 && segment.x === head.x && segment.y === head.y)) {
                if (!(gameState.activePowerUp && gameState.activePowerUp.type === 'immunity')) {
                    handleGameOver();
                    return;
                }
            }
            
            // Add new head to snake
            gameState.snake.unshift(head);
            
            // Check for food collision
            if (head.x === gameState.food.x && head.y === gameState.food.y) {
                // Find food type details
                const foodTypeDetails = gameState.foodTypes.find(type => type.type === gameState.food.type);
                
                // Calculate points
                let points = foodTypeDetails.points;
                
                // Apply multiplier if active
                if (gameState.activePowerUp && gameState.activePowerUp.type === 'multiplier') {
                    points *= 2;
                }
                
                // Update score
                gameState.score += points;
                updateScore();
                
                // Create particles
                createParticles(gameState.food.x + config.gridSize/2, gameState.food.y + config.gridSize/2, 
                                foodTypeDetails.color, 10);
                
                // Generate new food
                generateFood();
                
                // Increase speed slightly
                if (gameState.gameSpeed > config.maxSpeed) {
                    gameState.gameSpeed -= config.speedIncrease;
                }
            } 
            // Check for power-up collision
            else if (gameState.powerUp && head.x === gameState.powerUp.x && head.y === gameState.powerUp.y) {
                activatePowerUp(gameState.powerUp);
                gameState.powerUp = null;
            }
            else {
                // Remove tail if no food was eaten
                gameState.snake.pop();
            }
            
            // Update particles
            updateParticles();
        }

        // Activate power-up
        function activatePowerUp(powerUp) {
            // Clear any existing power-up timer
            if (gameState.powerUpTimer) {
                clearTimeout(gameState.powerUpTimer);
            }
            
            // Set active power-up
            gameState.activePowerUp = powerUp;
            
            // Show power-up indicator
            powerUpIcon.style.backgroundColor = powerUp.color;
            powerUpText.textContent = `${powerUp.icon} ${powerUp.type.charAt(0).toUpperCase() + powerUp.type.slice(1)}`;
            powerUpIndicator.classList.add('active');
            
            // Apply power-up effect
            if (powerUp.type === 'speed') {
                const originalSpeed = gameState.gameSpeed;
                gameState.gameSpeed = gameState.gameSpeed / 2; // Double speed
                
                // Reset speed after duration
                gameState.powerUpTimer = setTimeout(() => {
                    gameState.gameSpeed = originalSpeed;
                    deactivatePowerUp();
                }, powerUp.duration);
            } else {
                // For other power-ups, just set a timer to deactivate
                gameState.powerUpTimer = setTimeout(() => {
                    deactivatePowerUp();
                }, powerUp.duration);
            }
            
            // Create particles
            createParticles(powerUp.x + config.gridSize/2, powerUp.y + config.gridSize/2, 
                            powerUp.color, 20);
        }

        // Deactivate power-up
        function deactivatePowerUp() {
            gameState.activePowerUp = null;
            powerUpIndicator.classList.remove('active');
        }

        // Create particles
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2, // Initial upward velocity component
                    radius: 1 + Math.random() * 3,
                    color: color,
                    alpha: 1,
                    decay: 0.01 + Math.random() * 0.03
                });
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                
                // Apply gravity to particles
                p.vy += config.gravity * 0.1;
                
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= p.decay;
                
                // Check for particle collision with platforms
                for (const platform of gameState.platforms) {
                    if (p.y + p.radius >= platform.y && 
                        p.y - p.radius <= platform.y + platform.height &&
                        p.x + p.radius >= platform.x && 
                        p.x - p.radius <= platform.x + platform.width) {
                        // Simple bounce effect
                        p.vy = -p.vy * 0.6;
                        break;
                    }
                }
                
                if (p.alpha <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        // Handle game over
        function handleGameOver() {
            gameState.gameOver = true;
            
            // Update high score if needed
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('snakeHighScore', gameState.highScore);
                highScoreElement.textContent = `High Score: ${gameState.highScore}`;
            }
            
            // Update final score
            finalScoreElement.textContent = gameState.score;
            
            // Update high scores list
            updateHighScoresList();
            
            // Show game over screen with animation
            showScreen(gameOverScreen);
        }

        // Update score display
        function updateScore() {
            scoreElement.textContent = `Score: ${gameState.score}`;
        }

        // Update high scores list
        function updateHighScoresList() {
            // Get high scores from localStorage
            let highScores = JSON.parse(localStorage.getItem('snakeHighScores')) || [];
            
            // Add current score
            highScores.push(gameState.score);
            
            // Sort and keep only top 5
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 5);
            
            // Save back to localStorage
            localStorage.setItem('snakeHighScores', JSON.stringify(highScores));
            
            // Update display
            highScoresList.innerHTML = '';
            highScores.forEach(score => {
                const li = document.createElement('li');
                li.textContent = score;
                highScoresList.appendChild(li);
            });
        }


        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw platforms
            drawPlatforms();
            
            // Draw snake
            gameState.snake.forEach((segment, index) => {
                // Head has different style
                if (index === 0) {
                    ctx.fillStyle = gameState.easterEggActivated ? 
                        `hsl(${(Date.now() / 20) % 360}, 100%, 50%)` : '#e94560';
                } else {
                    // Body segments get progressively darker
                    const alpha = 1 - (index / gameState.snake.length) * 0.6;
                    ctx.fillStyle = gameState.easterEggActivated ? 
                        `hsla(${(Date.now() / 20 + index * 10) % 360}, 100%, 50%, ${alpha})` : 
                        `rgba(233, 69, 96, ${alpha})`;
                }
                
                // Draw segment with glow effect
                ctx.shadowColor = gameState.easterEggActivated ? 
                    `hsl(${(Date.now() / 20 + index * 10) % 360}, 100%, 50%)` : 
                    'rgba(233, 69, 96, 0.8)';

                ctx.shadowBlur = 10;
                
                // Draw rounded rectangle for segment
                const radius = 4;
                const x = segment.x;
                const y = segment.y;
                const size = config.gridSize;
                
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + size, y, x + size, y + size, radius);
                ctx.arcTo(x + size, y + size, x, y + size, radius);
                ctx.arcTo(x, y + size, x, y, radius);
                ctx.arcTo(x, y, x + size, y, radius);
                ctx.closePath();
                ctx.fill();
                
                // Reset shadow for other elements
                ctx.shadowBlur = 0;
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw snake
            gameState.snake.forEach((segment, index) => {
                // Head has different style (use sprite for head)
                if (index === 0 && gameState.spriteLoaded) {
                    // Save the current canvas state
                    ctx.save();
                    
                    // Translate to the center of the head segment for rotation
                    const centerX = segment.x + config.gridSize / 2;
                    const centerY = segment.y + config.gridSize / 2;
                    ctx.translate(centerX, centerY);
                    
                    // Rotate based on direction
                    switch(gameState.direction) {
                        case 'up':
                            ctx.rotate(-Math.PI/2); // 90 degrees counter-clockwise
                            break;
                        case 'down':
                            ctx.rotate(Math.PI/2); // 90 degrees clockwise
                            break;
                        case 'left':
                            ctx.rotate(Math.PI); // 180 degrees
                            break;
                        case 'right':
                            // No rotation needed as this is the default
                            break;
                    }
                    
                    // Translate back for drawing
                    ctx.translate(-centerX, -centerY);
                    
                    // Apply color tint for easter egg if active
                    if (gameState.easterEggActivated) {
                        // Create a colored rectangle for tinting
                        ctx.fillStyle = `hsl(${(Date.now() / 20) % 360}, 100%, 50%)`;
                        ctx.globalAlpha = 0.7;
                        ctx.fillRect(segment.x, segment.y, config.gridSize, config.gridSize);
                        
                        // Draw the sprite with composition
                        ctx.globalCompositeOperation = "lighter";
                        ctx.globalAlpha = 1.0;
                        ctx.drawImage(gameState.playerSprite, segment.x, segment.y, config.gridSize, config.gridSize);
                    } else {
                        // Draw the sprite normally with glow effect
                        ctx.shadowColor = 'rgba(233, 69, 96, 0.8)';
                        ctx.shadowBlur = 10;
                        ctx.drawImage(gameState.playerSprite, segment.x, segment.y, config.gridSize, config.gridSize);
                        ctx.shadowBlur = 0;
                    }
                    
                    // Restore the canvas state
                    ctx.restore();
                } else {
                    // Body segments remain the same
                    if (index === 0) {
                        // Fallback for head if sprite isn't loaded
                        ctx.fillStyle = gameState.easterEggActivated ? 
                            `hsl(${(Date.now() / 20) % 360}, 100%, 50%)` : '#e94560';
                    } else {
                        // Body segments get progressively darker
                        const alpha = 1 - (index / gameState.snake.length) * 0.6;
                        ctx.fillStyle = gameState.easterEggActivated ? 
                            `hsla(${(Date.now() / 20 + index * 10) % 360}, 100%, 50%, ${alpha})` : 
                            `rgba(233, 69, 96, ${alpha})`;
                    }
                    
                    // Draw segment with glow effect
                    ctx.shadowColor = gameState.easterEggActivated ? 
                        `hsl(${(Date.now() / 20 + index * 10) % 360}, 100%, 50%)` : 
                        'rgba(233, 69, 96, 0.8)';
                    ctx.shadowBlur = 10;
                    
                    // Draw rounded rectangle for segment
                    const radius = 4;
                    const x = segment.x;
                    const y = segment.y;
                    const size = config.gridSize;
                    
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.arcTo(x + size, y, x + size, y + size, radius);
                    ctx.arcTo(x + size, y + size, x, y + size, radius);
                    ctx.arcTo(x, y + size, x, y, radius);
                    ctx.arcTo(x, y, x + size, y, radius);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Reset shadow for other elements
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw food
            const foodType = gameState.foodTypes.find(type => type.type === gameState.food.type);
            if (foodType) {
                ctx.fillStyle = foodType.color;
                
                // Pulsating effect
                const pulseFactor = 1 + 0.2 * Math.sin(Date.now() / 200);
                const size = config.gridSize * foodType.size * pulseFactor;
                
                // Draw food with glow
                ctx.shadowColor = foodType.color;
                ctx.shadowBlur = 15;
                
                ctx.beginPath();
                ctx.arc(
                    gameState.food.x + config.gridSize / 2, 
                    gameState.food.y + config.gridSize / 2, 
                    size / 2, 0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            
            // Draw power-up if active
            if (gameState.powerUp) {
                ctx.fillStyle = gameState.powerUp.color;
                
                // Pulsating effect
                const pulseFactor = 1 + 0.3 * Math.sin(Date.now() / 150);
                const size = config.gridSize * 1.2 * pulseFactor;
                
                // Draw with glow
                ctx.shadowColor = gameState.powerUp.color;
                ctx.shadowBlur = 20;
                
                // Draw star shape for power-up
                const centerX = gameState.powerUp.x + config.gridSize / 2;
                const centerY = gameState.powerUp.y + config.gridSize / 2;
                const spikes = 5;
                const outerRadius = size / 2;
                const innerRadius = outerRadius / 2;
                
                ctx.beginPath();
                let rot = Math.PI / 2 * 3;
                const step = Math.PI / spikes;
                
                for (let i = 0; i < spikes; i++) {
                    const x1 = centerX + Math.cos(rot) * outerRadius;
                    const y1 = centerY + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x1, y1);
                    rot += step;
                    
                    const x2 = centerX + Math.cos(rot) * innerRadius;
                    const y2 = centerY + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x2, y2);
                    rot += step;
                }
                
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            
            // Draw particles
            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            

            ctx.globalAlpha = 1;
        }
        
        // Draw platforms
        function drawPlatforms() {
            gameState.platforms.forEach(platform => {
                const platformType = gameState.platformTypes[platform.type];
                if (platformType) {
                    // Check if we have images loaded
                    const platformImg = platformImages[platform.type];
                    if (platformImg && platformImg.complete) {
                        // Draw image
                        ctx.drawImage(platformImg, platform.x, platform.y, config.gridSize, config.gridSize);
                    } else {
                        // Fallback to colored rectangle
                        ctx.fillStyle = platformType.color;
                        ctx.shadowColor = platformType.color;
                        ctx.shadowBlur = 10;
                        ctx.fillRect(platform.x, platform.y, config.gridSize, config.gridSize);
                        ctx.shadowBlur = 0;
                    }
                }
            });

        }

        // Game loop
        function gameLoop(currentTime) {
            if (gameState.gameOver) return;
            
            window.requestAnimationFrame(gameLoop);
            
            // Calculate time since last render
            const timeSinceLastRender = currentTime - gameState.lastRenderTime;
            
            // Only update at specified game speed
            if (timeSinceLastRender < gameState.gameSpeed) return;
            
            // Update last render time
            gameState.lastRenderTime = currentTime;
            
            // Update game state
            update();
            
            // Draw game
            draw();
        }

        // Handle keyboard input
        function handleKeydown(e) {
            // Check for Konami code
            if (e.keyCode === gameState.konami[gameState.konamiIndex]) {
                gameState.konamiIndex++;
                if (gameState.konamiIndex === gameState.konami.length) {
                    gameState.easterEggActivated = !gameState.easterEggActivated;
                    gameState.konamiIndex = 0;
                }
            } else {
                gameState.konamiIndex = 0;
            }
            
            // Handle direction keys
            switch (e.keyCode) {
                // Arrow Up or W
                case 38:
                case 87:
                    if (gameState.direction !== 'down') {
                        gameState.nextDirection = 'up';
                    }
                    break;
                // Arrow Down or S
                case 40:
                case 83:
                    if (gameState.direction !== 'up') {
                        gameState.nextDirection = 'down';
                    }
                    break;
                // Arrow Left or A
                case 37:
                case 65:
                    if (gameState.direction !== 'right') {
                        gameState.nextDirection = 'left';
                    }
                    break;
                // Arrow Right or D
                case 39:
                case 68:
                    if (gameState.direction !== 'left') {
                        gameState.nextDirection = 'right';
                    }
                    break;
                // P key (pause)
                case 80:
                    togglePause();
                    break;
                // M key (mute)
                case 77:
                    toggleSound();
                    break;
            }
        }

        // Function to show a screen with animation
        function showScreen(screen) {
            // First hide all screens
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            
            // Then show the requested screen with a small delay for better transition
            setTimeout(() => {
                screen.classList.remove('hidden');
            }, 50);
        }
        
        // Toggle pause state
        function togglePause() {
            if (gameState.gameOver) return;
            
            gameState.paused = !gameState.paused;
            
            if (gameState.paused) {
                showScreen(pauseScreen);
            } else {
                pauseScreen.classList.add('hidden');
                window.requestAnimationFrame(gameLoop);
            }
        }

        // Toggle sound
        function toggleSound() {
            config.soundEnabled = !config.soundEnabled;
            soundToggle.textContent = config.soundEnabled ? '🔊' : '🔇';
        }

        // Event listeners
        window.addEventListener('keydown', handleKeydown);
        window.addEventListener('resize', setupCanvas);
        startButton.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            initGame();
        });
        restartButton.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            initGame();
        });
        resumeButton.addEventListener('click', togglePause);
        soundToggle.addEventListener('click', toggleSound);
        
        // Main menu buttons
        mainMenuButton.addEventListener('click', returnToMainMenu);
        gameOverMainMenuButton.addEventListener('click', returnToMainMenu);
        
        // Function to return to main menu
        function returnToMainMenu() {
            // Reset game state
            gameState.gameOver = true;
            gameState.paused = false;
            
            // Show start screen with animation
            showScreen(startScreen);
        }

        // Setup canvas initially
        setupCanvas();
        
        // Load player sprite
        loadPlayerSprite();
    </script>
</body>
</html>
