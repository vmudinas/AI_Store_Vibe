<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #e94560;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: linear-gradient(45deg, #0f0f1a, #1a1a2e);
        }

        .ui-container {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(233, 69, 96, 0.7);
        }

        .game-over, .start-screen, .pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            text-align: center;
            z-index: 10;
        }

        .hidden {
            display: none;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #e94560;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.7);
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #e94560;
        }

        p {
            margin: 10px 0;
            font-size: 1.2rem;
        }

        button {
            background: linear-gradient(45deg, #e94560, #c73e6b);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 10px;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.8);
        }

        .controls {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #ccc;
        }

        .high-scores {
            margin-top: 20px;
            width: 80%;
            max-width: 300px;
        }

        .high-scores h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .high-scores ol {
            text-align: left;
            padding-left: 20px;
        }

        .high-scores li {
            margin: 5px 0;
        }

        .power-up-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            background: rgba(10, 10, 20, 0.7);
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
            display: flex;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .power-up-indicator.active {
            opacity: 1;
        }

        .power-up-icon {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 50%;
        }

        .sound-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(10, 10, 20, 0.7);
            border: none;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 5;
        }

        @media (max-width: 600px) {
            .game-container {
                width: 95vw;
                height: auto;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .ui-container {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="score">Score: 0</div>
        <div id="high-score">High Score: 0</div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="power-up-indicator" id="powerUpIndicator">
            <div class="power-up-icon" id="powerUpIcon"></div>
            <span id="powerUpText"></span>
        </div>
        
        <button class="sound-toggle" id="soundToggle">üîä</button>
        
        <div class="start-screen" id="startScreen">
            <h1>Enhanced Snake Game</h1>
            <p>Use Arrow Keys or WASD to move</p>
            <p>Collect food to grow and earn points</p>
            <p>Watch out for special power-ups!</p>
            <button id="startButton">Start Game</button>
            <div class="controls">
                <p>P: Pause Game | M: Toggle Sound</p>
            </div>
        </div>
        
        <div class="game-over hidden" id="gameOverScreen">
            <h2>Game Over</h2>
            <p>Your Score: <span id="finalScore">0</span></p>
            <button id="restartButton">Play Again</button>
            <button id="gameOverMainMenuButton">Main Menu</button>
            
            <div class="high-scores">
                <h3>High Scores</h3>
                <ol id="highScoresList"></ol>
            </div>
        </div>
        
        <div class="pause-screen hidden" id="pauseScreen">
            <h2>Game Paused</h2>
            <button id="resumeButton">Resume</button>
            <button id="mainMenuButton">Main Menu</button>
        </div>
    </div>

    <script>
        // Game Configuration
        const config = {
            canvasWidth: 600,
            canvasHeight: 400,
            gridSize: 20,
            initialSpeed: 150,
            speedIncrease: 0.5,
            maxSpeed: 50,
            responsive: true,
            soundEnabled: true,
            musicVolume: 0.3,
            effectsVolume: 0.5
        };

        // Game State
        const gameState = {
            snake: [],
            direction: 'right',
            nextDirection: 'right',
            food: { x: 0, y: 0, type: 'regular' },
            score: 0,
            highScore: 0,
            gameOver: false,
            paused: false,
            lastRenderTime: 0,
            gameSpeed: config.initialSpeed,
            powerUp: null,
            particles: [],
            foodTypes: [
                { type: 'regular', color: '#e94560', points: 1, probability: 0.7, size: 1 },
                { type: 'bonus', color: '#ffbd69', points: 3, probability: 0.2, size: 1.2 },
                { type: 'special', color: '#00f5d4', points: 5, probability: 0.1, size: 1.5 }
            ],
            powerUps: [
                { type: 'speed', color: '#ff2e63', duration: 5000, icon: '‚ö°' },
                { type: 'immunity', color: '#00b8a9', duration: 8000, icon: 'üõ°Ô∏è' },
                { type: 'multiplier', color: '#8a2be2', duration: 10000, icon: '‚úñÔ∏è' }
            ],
            activePowerUp: null,
            powerUpTimer: null,
            konami: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65], // Up Up Down Down Left Right Left Right B A
            konamiIndex: 0,
            easterEggActivated: false
        };

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const finalScoreElement = document.getElementById('finalScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const pauseScreen = document.getElementById('pauseScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const resumeButton = document.getElementById('resumeButton');
        const highScoresList = document.getElementById('highScoresList');
        const powerUpIndicator = document.getElementById('powerUpIndicator');
        const powerUpIcon = document.getElementById('powerUpIcon');
        const powerUpText = document.getElementById('powerUpText');
        const soundToggle = document.getElementById('soundToggle');
        const mainMenuButton = document.getElementById('mainMenuButton');
        const gameOverMainMenuButton = document.getElementById('gameOverMainMenuButton');

        // Sound Manager
        const soundManager = {
            context: null,
            bgMusic: null,
            bgMusicNode: null,
            bgMusicGain: null,
            effectsGain: null,
            initialized: false,

            // Initialize audio context
            init() {
                if (this.initialized) return;
                
                // Create audio context
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create gain nodes for volume control
                this.bgMusicGain = this.context.createGain();
                this.bgMusicGain.gain.value = config.musicVolume;
                this.bgMusicGain.connect(this.context.destination);
                
                this.effectsGain = this.context.createGain();
                this.effectsGain.gain.value = config.effectsVolume;
                this.effectsGain.connect(this.context.destination);
                
                // Generate background music
                this.generateBgMusic();
                
                this.initialized = true;
            },
            
            // Generate a simple background music loop
            generateBgMusic() {
                const numNotes = 8;
                const noteDuration = 0.5;
                const totalDuration = numNotes * noteDuration;
                
                // Create buffer for the music loop
                const sampleRate = this.context.sampleRate;
                const buffer = this.context.createBuffer(1, sampleRate * totalDuration, sampleRate);
                const data = buffer.getChannelData(0);
                
                // Simple melody pattern
                const notes = [261.63, 329.63, 392.00, 523.25, 392.00, 329.63, 261.63, 329.63]; // C, E, G, C, G, E, C, E
                
                for (let i = 0; i < numNotes; i++) {
                    const freq = notes[i];
                    const startSample = Math.floor(i * noteDuration * sampleRate);
                    const endSample = Math.floor((i + 0.8) * noteDuration * sampleRate); // Note slightly shorter than full duration
                    
                    for (let j = startSample; j < endSample; j++) {
                        // Create a sine wave with fade in/out
                        const t = (j - startSample) / (endSample - startSample);
                        const envelope = 0.5 * Math.sin(Math.PI * t); // Simple amplitude envelope
                        data[j] += 0.3 * envelope * Math.sin(freq * 2 * Math.PI * (j - startSample) / sampleRate);
                    }
                }
                
                this.bgMusic = buffer;
            },
            
            // Play background music in a loop
            playBgMusic() {
                if (!this.initialized || !config.soundEnabled) return;
                
                // Stop any currently playing music
                if (this.bgMusicNode) {
                    this.bgMusicNode.stop();
                    this.bgMusicNode = null;
                }
                
                // Create buffer source
                this.bgMusicNode = this.context.createBufferSource();
                this.bgMusicNode.buffer = this.bgMusic;
                this.bgMusicNode.loop = true;
                this.bgMusicNode.connect(this.bgMusicGain);
                this.bgMusicNode.start();
            },
            
            // Stop background music
            stopBgMusic() {
                if (this.bgMusicNode) {
                    this.bgMusicNode.stop();
                    this.bgMusicNode = null;
                }
            },
            
            // Play a tone with specified parameters
            playTone(freq, duration, type = 'sine', volumeMultiplier = 1.0) {
                if (!this.initialized || !config.soundEnabled) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.type = type;
                oscillator.frequency.value = freq;
                
                gainNode.gain.value = config.effectsVolume * volumeMultiplier;
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                // Envelope to avoid clicks
                gainNode.gain.setValueAtTime(0, this.context.currentTime);
                gainNode.gain.linearRampToValueAtTime(config.effectsVolume * volumeMultiplier, this.context.currentTime + 0.01);
                gainNode.gain.linearRampToValueAtTime(0, this.context.currentTime + duration);
                
                oscillator.start();
                oscillator.stop(this.context.currentTime + duration);
            },
            
            // Play a food collection sound
            playFoodSound(foodType) {
                // Different sounds based on food type
                switch(foodType) {
                    case 'regular':
                        this.playTone(523.25, 0.1); // C5
                        break;
                    case 'bonus':
                        this.playTone(659.25, 0.2); // E5
                        this.playTone(783.99, 0.2, 'sine', 0.7); // G5
                        break;
                    case 'special':
                        this.playTone(523.25, 0.1); // C5
                        this.playTone(659.25, 0.1, 'sine', 0.8); // E5
                        this.playTone(783.99, 0.2, 'sine', 0.9); // G5
                        break;
                }
            },
            
            // Play power-up collection sound
            playPowerUpSound(powerUpType) {
                switch(powerUpType) {
                    case 'speed':
                        // Rising tone for speed
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                this.playTone(440 + i * 100, 0.1, 'square', 0.4);
                            }, i * 80);
                        }
                        break;
                    case 'immunity':
                        // Immunity shield sound
                        this.playTone(392, 0.3, 'sine', 0.6);
                        setTimeout(() => this.playTone(587.33, 0.4, 'sine', 0.4), 200);
                        break;
                    case 'multiplier':
                        // Multiplier sound
                        this.playTone(523.25, 0.2, 'sawtooth', 0.4);
                        setTimeout(() => this.playTone(659.25, 0.3, 'sawtooth', 0.3), 150);
                        setTimeout(() => this.playTone(783.99, 0.4, 'sawtooth', 0.4), 300);
                        break;
                }
            },
            
            // Play game over sound
            playGameOverSound() {
                // Descending sad tone
                this.playTone(493.88, 0.3, 'sawtooth', 0.5); // B4
                setTimeout(() => this.playTone(392.00, 0.5, 'sawtooth', 0.6), 250); // G4
                setTimeout(() => this.playTone(329.63, 0.7, 'sawtooth', 0.7), 600); // E4
            },
            
            // Play button click sound
            playButtonSound() {
                this.playTone(587.33, 0.1, 'square', 0.3); // D5
            },
            
            // Update sound state based on config
            updateSoundState() {
                if (config.soundEnabled) {
                    // Resume context if suspended
                    if (this.context && this.context.state === 'suspended') {
                        this.context.resume();
                    }
                    
                    // Start bg music if not playing and game is active
                    if (!gameState.gameOver && !gameState.paused) {
                        this.playBgMusic();
                    }
                } else {
                    // Stop all sounds
                    this.stopBgMusic();
                }
            }
        };

        // Initialize canvas size
        function setupCanvas() {
            if (config.responsive) {
                const containerWidth = Math.min(window.innerWidth * 0.95, config.canvasWidth);
                const containerHeight = Math.min(window.innerHeight * 0.7, config.canvasHeight);
                
                canvas.width = Math.floor(containerWidth / config.gridSize) * config.gridSize;
                canvas.height = Math.floor(containerHeight / config.gridSize) * config.gridSize;
            } else {
                canvas.width = config.canvasWidth;
                canvas.height = config.canvasHeight;
            }
        }

        // Initialize game
        function initGame() {
            setupCanvas();
            
            // Create initial snake
            gameState.snake = [
                { x: Math.floor(canvas.width / config.gridSize / 2) * config.gridSize, 
                  y: Math.floor(canvas.height / config.gridSize / 2) * config.gridSize }
            ];
            
            gameState.direction = 'right';
            gameState.nextDirection = 'right';
            gameState.score = 0;
            gameState.gameOver = false;
            gameState.gameSpeed = config.initialSpeed;
            gameState.particles = [];
            gameState.activePowerUp = null;
            gameState.easterEggActivated = false;
            
            if (gameState.powerUpTimer) {
                clearTimeout(gameState.powerUpTimer);
                gameState.powerUpTimer = null;
            }
            
            // Load high score from localStorage
            const savedHighScore = localStorage.getItem('snakeHighScore');
            if (savedHighScore) {
                gameState.highScore = parseInt(savedHighScore);
                highScoreElement.textContent = `High Score: ${gameState.highScore}`;
            }
            
            // Generate initial food
            generateFood();
            
            // Update score display
            updateScore();
            
            // Initialize audio if needed and play background music
            if (config.soundEnabled && !soundManager.initialized) {
                soundManager.init();
            }
            
            if (config.soundEnabled) {
                soundManager.playBgMusic();
            }
            
            // Start game loop
            window.requestAnimationFrame(gameLoop);
        }

        // Generate food at random position
        function generateFood() {
            // Determine food type based on probability
            let foodType;
            const rand = Math.random();
            let cumulativeProbability = 0;
            
            for (const type of gameState.foodTypes) {
                cumulativeProbability += type.probability;
                if (rand <= cumulativeProbability) {
                    foodType = type.type;
                    break;
                }
            }
            
            // Generate random position that doesn't overlap with snake
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * (canvas.width / config.gridSize)) * config.gridSize,
                    y: Math.floor(Math.random() * (canvas.height / config.gridSize)) * config.gridSize
                };
            } while (isPositionOccupied(position));
            
            gameState.food = { ...position, type: foodType };
            
            // Occasionally spawn a power-up (10% chance when no active power-up)
            if (!gameState.activePowerUp && Math.random() < 0.1) {
                generatePowerUp();
            }
        }

        // Generate power-up at random position
        function generatePowerUp() {
            // Select random power-up type
            const powerUpType = gameState.powerUps[Math.floor(Math.random() * gameState.powerUps.length)];
            
            // Generate random position that doesn't overlap with snake or food
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * (canvas.width / config.gridSize)) * config.gridSize,
                    y: Math.floor(Math.random() * (canvas.height / config.gridSize)) * config.gridSize
                };
            } while (isPositionOccupied(position) || 
                    (position.x === gameState.food.x && position.y === gameState.food.y));
            
            gameState.powerUp = { ...position, ...powerUpType };
        }

        // Check if position is occupied by snake
        function isPositionOccupied(position) {
            return gameState.snake.some(segment => 
                segment.x === position.x && segment.y === position.y
            );
        }

        // Update game state
        function update() {
            if (gameState.gameOver || gameState.paused) return;
            
            // Get current head position
            const head = { ...gameState.snake[0] };
            
            // Update direction
            gameState.direction = gameState.nextDirection;
            
            // Calculate new head position based on direction
            switch (gameState.direction) {
                case 'up':
                    head.y -= config.gridSize;
                    break;
                case 'down':
                    head.y += config.gridSize;
                    break;
                case 'left':
                    head.x -= config.gridSize;
                    break;
                case 'right':
                    head.x += config.gridSize;
                    break;
            }
            
            // Check for wall collision
            if (head.x < 0 || head.x >= canvas.width || 
                head.y < 0 || head.y >= canvas.height) {
                if (gameState.activePowerUp && gameState.activePowerUp.type === 'immunity') {
                    // Wrap around with immunity
                    if (head.x < 0) head.x = canvas.width - config.gridSize;
                    if (head.x >= canvas.width) head.x = 0;
                    if (head.y < 0) head.y = canvas.height - config.gridSize;
                    if (head.y >= canvas.height) head.y = 0;
                } else {
                    handleGameOver();
                    return;
                }
            }
            
            // Check for self collision
            if (gameState.snake.some((segment, index) => 
                index > 0 && segment.x === head.x && segment.y === head.y)) {
                if (!(gameState.activePowerUp && gameState.activePowerUp.type === 'immunity')) {
                    handleGameOver();
                    return;
                }
            }
            
            // Add new head to snake
            gameState.snake.unshift(head);
            
            // Check for food collision
            if (head.x === gameState.food.x && head.y === gameState.food.y) {
                // Find food type details
                const foodTypeDetails = gameState.foodTypes.find(type => type.type === gameState.food.type);
                
                // Calculate points
                let points = foodTypeDetails.points;
                
                // Apply multiplier if active
                if (gameState.activePowerUp && gameState.activePowerUp.type === 'multiplier') {
                    points *= 2;
                }
                
                // Update score
                gameState.score += points;
                updateScore();
                
                // Play food collection sound
                if (config.soundEnabled) {
                    soundManager.playFoodSound(gameState.food.type);
                }
                
                // Create particles
                createParticles(gameState.food.x + config.gridSize/2, gameState.food.y + config.gridSize/2, 
                                foodTypeDetails.color, 10);
                
                // Generate new food
                generateFood();
                
                // Increase speed slightly
                if (gameState.gameSpeed > config.maxSpeed) {
                    gameState.gameSpeed -= config.speedIncrease;
                }
            } 
            // Check for power-up collision
            else if (gameState.powerUp && head.x === gameState.powerUp.x && head.y === gameState.powerUp.y) {
                activatePowerUp(gameState.powerUp);
                gameState.powerUp = null;
            }
            else {
                // Remove tail if no food was eaten
                gameState.snake.pop();
            }
            
            // Update particles
            updateParticles();
        }

        // Activate power-up
        function activatePowerUp(powerUp) {
            // Clear any existing power-up timer
            if (gameState.powerUpTimer) {
                clearTimeout(gameState.powerUpTimer);
            }
            
            // Set active power-up
            gameState.activePowerUp = powerUp;
            
            // Show power-up indicator
            powerUpIcon.style.backgroundColor = powerUp.color;
            powerUpText.textContent = `${powerUp.icon} ${powerUp.type.charAt(0).toUpperCase() + powerUp.type.slice(1)}`;
            powerUpIndicator.classList.add('active');
            
            // Apply power-up effect
            if (powerUp.type === 'speed') {
                const originalSpeed = gameState.gameSpeed;
                gameState.gameSpeed = gameState.gameSpeed / 2; // Double speed
                
                // Reset speed after duration
                gameState.powerUpTimer = setTimeout(() => {
                    gameState.gameSpeed = originalSpeed;
                    deactivatePowerUp();
                }, powerUp.duration);
            } else {
                // For other power-ups, just set a timer to deactivate
                gameState.powerUpTimer = setTimeout(() => {
                    deactivatePowerUp();
                }, powerUp.duration);
            }
            
            // Create particles
            createParticles(powerUp.x + config.gridSize/2, powerUp.y + config.gridSize/2, 
                            powerUp.color, 20);
                            
            // Play power-up sound
            if (config.soundEnabled) {
                soundManager.playPowerUpSound(powerUp.type);
            }
        }

        // Deactivate power-up
        function deactivatePowerUp() {
            gameState.activePowerUp = null;
            powerUpIndicator.classList.remove('active');
        }

        // Create particles
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 1 + Math.random() * 3,
                    color: color,
                    alpha: 1,
                    decay: 0.01 + Math.random() * 0.03
                });
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= p.decay;
                
                if (p.alpha <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        // Handle game over
        function handleGameOver() {
            gameState.gameOver = true;
            
            // Play game over sound
            if (config.soundEnabled) {
                soundManager.stopBgMusic();
                soundManager.playGameOverSound();
            }
            
            // Update high score if needed
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('snakeHighScore', gameState.highScore);
                highScoreElement.textContent = `High Score: ${gameState.highScore}`;
            }
            
            // Update final score
            finalScoreElement.textContent = gameState.score;
            
            // Update high scores list
            updateHighScoresList();
            
            // Show game over screen
            gameOverScreen.classList.remove('hidden');
        }

        // Update score display
        function updateScore() {
            scoreElement.textContent = `Score: ${gameState.score}`;
        }

        // Update high scores list
        function updateHighScoresList() {
            // Get high scores from localStorage
            let highScores = JSON.parse(localStorage.getItem('snakeHighScores')) || [];
            
            // Add current score
            highScores.push(gameState.score);
            
            // Sort and keep only top 5
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 5);
            
            // Save back to localStorage
            localStorage.setItem('snakeHighScores', JSON.stringify(highScores));
            
            // Update display
            highScoresList.innerHTML = '';
            highScores.forEach(score => {
                const li = document.createElement('li');
                li.textContent = score;
                highScoresList.appendChild(li);
            });
        }

        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw snake
            gameState.snake.forEach((segment, index) => {
                // Head has different style
                if (index === 0) {
                    ctx.fillStyle = gameState.easterEggActivated ? 
                        `hsl(${(Date.now() / 20) % 360}, 100%, 50%)` : '#e94560';
                } else {
                    // Body segments get progressively darker
                    const alpha = 1 - (index / gameState.snake.length) * 0.6;
                    ctx.fillStyle = gameState.easterEggActivated ? 
                        `hsla(${(Date.now() / 20 + index * 10) % 360}, 100%, 50%, ${alpha})` : 
                        `rgba(233, 69, 96, ${alpha})`;
                }
                
                // Draw segment with glow effect
                ctx.shadowColor = gameState.easterEggActivated ? 
                    `hsl(${(Date.now() / 20 + index * 10) % 360}, 100%, 50%)` : 
                    'rgba(233, 69, 96, 0.8)';
                ctx.shadowBlur = 10;
                
                // Draw rounded rectangle for segment
                const radius = 4;
                const x = segment.x;
                const y = segment.y;
                const size = config.gridSize;
                
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.arcTo(x + size, y, x + size, y + size, radius);
                ctx.arcTo(x + size, y + size, x, y + size, radius);
                ctx.arcTo(x, y + size, x, y, radius);
                ctx.arcTo(x, y, x + size, y, radius);
                ctx.closePath();
                ctx.fill();
                
                // Reset shadow for other elements
                ctx.shadowBlur = 0;
            });
            
            // Draw food
            const foodType = gameState.foodTypes.find(type => type.type === gameState.food.type);
            if (foodType) {
                ctx.fillStyle = foodType.color;
                
                // Pulsating effect
                const pulseFactor = 1 + 0.2 * Math.sin(Date.now() / 200);
                const size = config.gridSize * foodType.size * pulseFactor;
                
                // Draw food with glow
                ctx.shadowColor = foodType.color;
                ctx.shadowBlur = 15;
                
                ctx.beginPath();
                ctx.arc(
                    gameState.food.x + config.gridSize / 2, 
                    gameState.food.y + config.gridSize / 2, 
                    size / 2, 0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            
            // Draw power-up if active
            if (gameState.powerUp) {
                ctx.fillStyle = gameState.powerUp.color;
                
                // Pulsating effect
                const pulseFactor = 1 + 0.3 * Math.sin(Date.now() / 150);
                const size = config.gridSize * 1.2 * pulseFactor;
                
                // Draw with glow
                ctx.shadowColor = gameState.powerUp.color;
                ctx.shadowBlur = 20;
                
                // Draw star shape for power-up
                const centerX = gameState.powerUp.x + config.gridSize / 2;
                const centerY = gameState.powerUp.y + config.gridSize / 2;
                const spikes = 5;
                const outerRadius = size / 2;
                const innerRadius = outerRadius / 2;
                
                ctx.beginPath();
                let rot = Math.PI / 2 * 3;
                const step = Math.PI / spikes;
                
                for (let i = 0; i < spikes; i++) {
                    const x1 = centerX + Math.cos(rot) * outerRadius;
                    const y1 = centerY + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x1, y1);
                    rot += step;
                    
                    const x2 = centerX + Math.cos(rot) * innerRadius;
                    const y2 = centerY + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x2, y2);
                    rot += step;
                }
                
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
            
            // Draw particles
            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.globalAlpha = 1;
        }

        // Game loop
        function gameLoop(currentTime) {
            if (gameState.gameOver) return;
            
            window.requestAnimationFrame(gameLoop);
            
            // Calculate time since last render
            const timeSinceLastRender = currentTime - gameState.lastRenderTime;
            
            // Only update at specified game speed
            if (timeSinceLastRender < gameState.gameSpeed) return;
            
            // Update last render time
            gameState.lastRenderTime = currentTime;
            
            // Update game state
            update();
            
            // Draw game
            draw();
        }

        // Handle keyboard input
        function handleKeydown(e) {
            // Check for Konami code
            if (e.keyCode === gameState.konami[gameState.konamiIndex]) {
                gameState.konamiIndex++;
                if (gameState.konamiIndex === gameState.konami.length) {
                    gameState.easterEggActivated = !gameState.easterEggActivated;
                    gameState.konamiIndex = 0;
                }
            } else {
                gameState.konamiIndex = 0;
            }
            
            // Handle direction keys
            switch (e.keyCode) {
                // Arrow Up or W
                case 38:
                case 87:
                    if (gameState.direction !== 'down') {
                        gameState.nextDirection = 'up';
                    }
                    break;
                // Arrow Down or S
                case 40:
                case 83:
                    if (gameState.direction !== 'up') {
                        gameState.nextDirection = 'down';
                    }
                    break;
                // Arrow Left or A
                case 37:
                case 65:
                    if (gameState.direction !== 'right') {
                        gameState.nextDirection = 'left';
                    }
                    break;
                // Arrow Right or D
                case 39:
                case 68:
                    if (gameState.direction !== 'left') {
                        gameState.nextDirection = 'right';
                    }
                    break;
                // P key (pause)
                case 80:
                    togglePause();
                    break;
                // M key (mute)
                case 77:
                    toggleSound();
                    break;
            }
        }

        // Function to show a screen with animation
        function showScreen(screen) {
            // First hide all screens
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            
            // Then show the requested screen with a small delay for better transition
            setTimeout(() => {
                screen.classList.remove('hidden');
            }, 50);
        }
        
        // Toggle pause state
        function togglePause() {
            if (gameState.gameOver) return;
            
            gameState.paused = !gameState.paused;
            
            if (gameState.paused) {
                showScreen(pauseScreen);
                // Pause background music
                if (config.soundEnabled) {
                    soundManager.stopBgMusic();
                }
            } else {
                pauseScreen.classList.add('hidden');
                // Resume background music
                if (config.soundEnabled) {
                    soundManager.playBgMusic();
                }
                window.requestAnimationFrame(gameLoop);
            }
            
            // Play button sound
            if (config.soundEnabled) {
                soundManager.playButtonSound();
            }
        }

        // Toggle sound
        function toggleSound() {
            config.soundEnabled = !config.soundEnabled;
            soundToggle.textContent = config.soundEnabled ? 'üîä' : 'üîá';
            
            // Initialize sound if first time enabling
            if (config.soundEnabled && !soundManager.initialized) {
                soundManager.init();
            }
            
            soundManager.updateSoundState();
            
            // Play button sound if enabling
            if (config.soundEnabled) {
                soundManager.playButtonSound();
            }
        }

        // Event listeners
        window.addEventListener('keydown', handleKeydown);
        window.addEventListener('resize', setupCanvas);
        startButton.addEventListener('click', () => {
            // Play button sound
            if (config.soundEnabled) {
                if (!soundManager.initialized) {
                    soundManager.init();
                }
                soundManager.playButtonSound();
            }
            startScreen.classList.add('hidden');
            initGame();
        });
        restartButton.addEventListener('click', () => {
            // Play button sound
            if (config.soundEnabled) {
                soundManager.playButtonSound();
            }
            gameOverScreen.classList.add('hidden');
            initGame();
        });
        resumeButton.addEventListener('click', togglePause);
        soundToggle.addEventListener('click', toggleSound);
        
        // Main menu buttons
        mainMenuButton.addEventListener('click', returnToMainMenu);
        gameOverMainMenuButton.addEventListener('click', returnToMainMenu);
        
        // Function to return to main menu
        function returnToMainMenu() {
            // Reset game state
            gameState.gameOver = true;
            gameState.paused = false;
            
            // Show start screen with animation
            showScreen(startScreen);
        }

        // Load player sprite for snake head
        function loadPlayerSprite() {
            // This is a placeholder implementation
            // In the actual implementation, this would load the sprite image
            gameState.playerSprite = new Image();
            gameState.playerSprite.src = ''; // Empty for now as a placeholder
            
            // Add a load event just to be safe
            gameState.playerSprite.onload = function() {
                console.log("Player sprite loaded");
            };
            
            // Error handling
            gameState.playerSprite.onerror = function() {
                console.log("Could not load player sprite");
            };
        }

        // Setup canvas initially
        setupCanvas();
        
        // Load player sprite
        loadPlayerSprite();

        // Add listener to initialize audio on first user interaction
        // This is required by browsers to allow audio playback
        document.addEventListener('click', function initAudio() {
            if (config.soundEnabled && !soundManager.initialized) {
                soundManager.init();
            }
            document.removeEventListener('click', initAudio);
        });
    </script>
</body>
</html>
